#!/usr/bin/python

import json
import sys
import re
import copy
import os

BLUE = '\033[94m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
RED = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'

class colortext:
  def __init__(self, text, color):
    self.text = text
    self.color = color
  def __len__(self):
    return len(self.text)
  def __str__(self):
    return BOLD + self.color + self.text + ENDC
def green(s):
  return colortext(s, GREEN)
def red(s):
  return colortext(s, RED)

def displayTag(t):
  return t

def json_careful_loads(s):
  try:
    return json.loads(s)
  except Exception as e:
    sys.stderr.write("[ERR] Error while parsing json: {}\n".format(e))
    sys.exit(1)

def json_careful_readlines(f):
  return [ json_careful_loads(line.rstrip('\n')) for line in f ]

def safeInsert(dict, key, value):
  if key not in dict:
    dict[key] = value
  else:
    sys.stderr.write("[WARN] Key {} is already in use; trying _{} instead.\n".format(key))
    safeInsert(dict, "_" + key, value)

def reCompile(exp):
  return re.compile(exp, re.MULTILINE)

statsPatterns = \
  [ ("time", int, reCompile(r"^wall\s+(\d+)$"))
  , ("space", int, reCompile(r"^\s*Maximum resident set size \(kbytes\): (\d+).*$"))
  ]

renameConfig = {
  'mlton': 'mlton',
  'mpl': 'mpl',
  'mpl-cc': 'mpl-cc'
}

foundTags = set()
foundProcs = set()

def parseStats(row):
  newRow = copy.deepcopy(row)
  for (name, convert, pat) in statsPatterns:
    m = pat.search(newRow['stdout'] + newRow['stderr'])
    if m:
      safeInsert(newRow, name, convert(m.group(1)))
  newRow['procs'] = int(newRow.get('procs', '1'))
  newRow['config'] = renameConfig[row['config']]

  try:
    newRow['space'] = float(newRow['space'])
  except KeyError:
    pass

  try:
    newRow['time'] = float(newRow['elapsed'])
  except KeyError:
    pass

  foundTags.add(newRow['tag'])
  foundProcs.add(newRow['procs'])

  return newRow

def averageTime(data, config, tag, procs):
  times = []
  for row in data:
    if row['config'] == config and row['tag'] == tag and row['procs'] == procs and 'time' in row:
      times.append(row['time'])
  try:
    return sum(times) / len(times)
  except:
    raise ValueError('Error processing average time of config={}, tag={}, procs={}'.format(config, tag, procs))

def averageSpace(data, config, tag, procs):
  sp = []
  for row in data:
    if row['config'] == config and row['tag'] == tag and row['procs'] == procs and 'space' in row:
      sp.append(row['space'])
  try:
    return sum(sp) / len(sp)
  except:
    raise ValueError('Error processing average space of config={}, tag={}, procs={}'.format(config, tag, procs))

def tm(t):
  # if t > 10.0:
  #   return int(round(t))
  try:
    if t >= 1.0:
      return round(t, 1)
    elif t >= 0.1:
      return round(t, 2)
    else:
      return round(t, 3)
  except TypeError:
    print ("[ERR] Got type error trying to round {}".format(repr(t)))
    return None

def noLeadZero(t):
  if t < 1:
    return str(t).replace('0', '', 1)
  return str(t)

def sp(kb):
  num = kb
  for unit in ['K','M','G']:
    if num < 1000:
      return "%3.1f %s" % (num, unit)
    num = num / 1000
  return "%3.1f %s" % (num, 'T')

# =========================================================================

def makeline(row, widths, justify):
  bits = []
  i = 0
  while i < len(row):
    j = i+1
    while j < len(row) and (row[j] is None):
      j += 1
    availableWidth = sum(widths[i:j]) + 3*(j-i-1)
    s = str(row[i])
    w = " " * (availableWidth - len(row[i]))
    if justify(i) == "l":
      ln = s + w
    elif justify(i) == "r":
      ln = w + s
    elif justify(i) == "c":
      ln = w[:len(w)/2] + s + w[len(w)/2:]
    else:
      raise ValueError("invalid formatter: {}".format(justify))
    bits.append(ln)
    i = j
  return "   ".join(bits)

def table(rows, justify=None):
  numCols = max(len(row) for row in rows if not isinstance(row, str))

  widths = [0] * numCols
  for row in rows:
    # string rows are used for formatting
    if isinstance(row, str):
      continue

    i = 0
    while i < len(row):
      j = i+1
      while j < len(row) and (row[j] is None):
        j += 1
      # rw = len(stripANSI(str(row[i])))
      # rw = len(str(row[i]))
      rw = len(row[i])
      for k in xrange(i, j):
        w = (rw / (j-i)) + (1 if k < rw % (j-i) else 0)
        widths[k] = max(widths[k], w)
      i = j

  totalWidth = sum(widths) + 3*(numCols-1)

  def just(i):
    try:
      return justify(i)
    except:
      return "l"

  output = []
  for row in rows:
    if row == "-" or row == "=":
      output.append(row * totalWidth)
      continue
    elif isinstance(row, str):
      raise ValueError("bad row: {}".format(row))
    output.append(makeline(row, widths, just))

  return "\n".join(output)

# =========================================================================

if len(sys.argv) > 1:
  inputFile = sys.argv[1]
else:
  print("[INFO] no results file argument; finding most recent")
  files = os.listdir("results")
  try:
    # A bit of a hack. Filenames are YYMMDD-hhmmss, so lexicographic string
    # comparison is correct for finding the most recent (i.e. maximum) file
    mostRecent = max(p for p in files if re.match(r'\d{6}-\d{6}', p))
  except:
    print("[ERR] could not find most recent results file\n " + \
          "  check that these are formatted as 'YYMMSS-hhmmss'")
    sys.exit(1)
  inputFile = os.path.join('results', mostRecent)

print("[INFO] reading {}\n".format(inputFile))
with open(inputFile, 'r') as data:
  resultsData = json_careful_readlines(data)
D = [ parseStats(row) for row in resultsData ]
P = sorted(list(foundProcs))
maxp = max(foundProcs)

def just(i):
  return "r" if i == 0 else "l"

headers = ['Benchmark', 'MLton', 'MPL(1)', 'MPL/CC(1)', 'MPL({})'.format(maxp), 'MPL/CC({})'.format(maxp)]
tt = [headers, "="]
for tag in foundTags:
  thisRow = [tag,
             tm(averageTime(D, 'mlton', tag, 1)),
             tm(averageTime(D, 'mpl', tag, 1)),
             tm(averageTime(D, 'mpl-cc', tag, 1)),
             tm(averageTime(D, 'mpl', tag, maxp)),
             tm(averageTime(D, 'mpl-cc', tag, maxp))
            ]
  thisRow = [thisRow[0]] + [str(x) for x in thisRow[1:]]
  tt.append(thisRow)

print("TIMINGS")
print(table(tt, just))
print("")

headers = ['Benchmark', 'MLton', 'MPL(1)', 'MPL/CC(1)', 'MPL({})'.format(maxp), 'MPL/CC({})'.format(maxp)]
tt = [headers, "="]
for tag in foundTags:
  thisRow = [tag,
             sp(averageSpace(D, 'mlton', tag, 1)),
             sp(averageSpace(D, 'mpl', tag, 1)),
             sp(averageSpace(D, 'mpl-cc', tag, 1)),
             sp(averageSpace(D, 'mpl', tag, maxp)),
             sp(averageSpace(D, 'mpl-cc', tag, maxp))
            ]
  tt.append(thisRow)

print("SPACE (MAX RESIDENCY)")
print(table(tt, just))
print("")

# percent difference (b-a)/|a|
def pcd(b, a):
  xx = 100.0 * (b-a) / abs(a)
  result = ("+" if xx >= 0.0 else "") + ("{:.1f}%".format(xx))
  if xx > 0.0:
    return red(result)
  else:
    return result

header1 = ["", "Overhead", None, "Speedup({})".format(maxp), None, "Blowup(1)", None, "Blowup({})".format(maxp), None]
header2 = ['Benchmark',
           'MPL',
           'MPL/CC',
           'MPL',
           'MPL/CC',
           'MPL',
           'MPL/CC',
           'MPL',
           'MPL/CC']
tt = [header1, header2, "="]
for tag in foundTags:
  tMLton = tm(averageTime(D, 'mlton', tag, 1))
  tMPL1 = tm(averageTime(D, 'mpl', tag, 1))
  tMPLp = tm(averageTime(D, 'mpl', tag, maxp))
  tMPLcc1 = tm(averageTime(D, 'mpl-cc', tag, 1))
  tMPLccp = tm(averageTime(D, 'mpl-cc', tag, maxp))
  rMLton = averageSpace(D, 'mlton', tag, 1)
  rMPL1 = averageSpace(D, 'mpl', tag, 1)
  rMPLp = averageSpace(D, 'mpl', tag, maxp)
  rMPLcc1 = averageSpace(D, 'mpl-cc', tag, 1)
  rMPLccp = averageSpace(D, 'mpl-cc', tag, maxp)

  overhead = tm(tMPL1 / tMLton)
  overheadcc = tm(tMPLcc1 / tMLton)
  speedup = tm(tMLton / tMPLp)
  speedupcc = tm(tMLton / tMPLccp)
  blowup1 = tm(rMPL1 / rMLton)
  blowupcc1 = tm(rMPLcc1 / rMLton)
  blowupp = tm(rMPLp / rMLton)
  blowupccp = tm(rMPLccp / rMLton)

  row = [tag, overhead, overheadcc, speedup, speedupcc, blowup1, blowupcc1, blowupp, blowupccp]
  row = [row[0]] + map(lambda x: "{:.1f}".format(x), row[1:])
  tt.append(row)

print("COMPARISON WITH MLTON")
print("Blowup(p) = (MPL(p) space) / (MLton space)")
print(table(tt, just))
print("")

header = ["Benchmark", "Time(1)", "Time({})".format(maxp), "Space(1)", "Space({})".format(maxp)]
tt = [header, "="]
for tag in foundTags:
  # tMLton = tm(averageTime(D, 'mlton', tag, 1))
  tMPL1 = tm(averageTime(D, 'mpl', tag, 1))
  tMPLp = tm(averageTime(D, 'mpl', tag, maxp))
  tMPLcc1 = tm(averageTime(D, 'mpl-cc', tag, 1))
  tMPLccp = tm(averageTime(D, 'mpl-cc', tag, maxp))
  # rMLton = averageSpace(D, 'mlton', tag, 1)
  rMPL1 = averageSpace(D, 'mpl', tag, 1)
  rMPLp = averageSpace(D, 'mpl', tag, maxp)
  rMPLcc1 = averageSpace(D, 'mpl-cc', tag, 1)
  rMPLccp = averageSpace(D, 'mpl-cc', tag, maxp)

  t1 = pcd(tMPLcc1, tMPL1)
  tp = pcd(tMPLccp, tMPLp)
  r1 = pcd(rMPLcc1, rMPL1)
  rp = pcd(rMPLccp, rMPLp)

  row = [tag, t1, tp, r1, rp]
  tt.append(row)

print("MPL/CC versus MPL")
print(table(tt, just))
print("")

print("[INFO] done reporting {}".format(inputFile))
